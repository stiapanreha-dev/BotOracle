"""
Engagement Manager - manages user engagement sessions for subscription conversion.

This module handles:
- Creating engagement sessions after daily messages
- Tracking messages and engagement level
- AI-powered conversation analysis
- Generating personalized Oracle question offers
- Managing session lifecycle (pause, conversion)
"""

from datetime import datetime, timedelta
from typing import Optional, Dict, Any, List
from app.database.connection import db
from app.services.ai_router import call_admin_ai
import logging

logger = logging.getLogger(__name__)


class EngagementManager:
    """Manages engagement sessions for conversion funnel optimization"""

    # Configuration constants
    LOW_ENGAGEMENT_THRESHOLD = 2  # 1-2 messages = low engagement
    HIGH_ENGAGEMENT_THRESHOLD = 3  # 3+ messages = high engagement
    COLLECTION_MIN_MESSAGES = 5  # Minimum messages before AI analysis
    COLLECTION_MAX_MESSAGES = 10  # Maximum messages to collect
    SESSION_TIMEOUT_HOURS = 24  # Auto-pause after 24 hours

    @staticmethod
    async def start_session(user_id: int) -> Optional[int]:
        """
        Create new engagement session for user after daily message.

        Args:
            user_id: Internal user ID (from users table)

        Returns:
            session_id if created, None if user already has active session
        """
        # Check if user already has an active session
        existing = await db.fetchrow(
            """
            SELECT id FROM engagement_sessions
            WHERE user_id = $1
            AND status IN ('engaging', 'collecting', 'offered')
            """,
            user_id
        )

        if existing:
            logger.info(f"User {user_id} already has active engagement session {existing['id']}")
            return None

        # Create new session
        session = await db.fetchrow(
            """
            INSERT INTO engagement_sessions (user_id, status, started_at, updated_at)
            VALUES ($1, 'engaging', NOW(), NOW())
            RETURNING id
            """,
            user_id
        )

        session_id = session['id']
        logger.info(f"Created engagement session {session_id} for user {user_id}")
        return session_id

    @staticmethod
    async def get_active_session(user_id: int) -> Optional[Dict[str, Any]]:
        """
        Get active engagement session for user.

        Returns:
            Session dict or None
        """
        session = await db.fetchrow(
            """
            SELECT * FROM engagement_sessions
            WHERE user_id = $1
            AND status IN ('engaging', 'collecting', 'offered')
            ORDER BY started_at DESC
            LIMIT 1
            """,
            user_id
        )

        return dict(session) if session else None

    @staticmethod
    async def track_message(session_id: int, role: str, content: str) -> None:
        """
        Track message in engagement session.

        Args:
            session_id: Engagement session ID
            role: 'user' or 'admin'
            content: Message text
        """
        # Save message
        await db.execute(
            """
            INSERT INTO session_messages (session_id, role, content, created_at)
            VALUES ($1, $2, $3, NOW())
            """,
            session_id, role, content
        )

        # Increment messages count
        await db.execute(
            """
            UPDATE engagement_sessions
            SET messages_count = messages_count + 1,
                updated_at = NOW()
            WHERE id = $1
            """,
            session_id
        )

        logger.debug(f"Tracked {role} message in session {session_id}")

    @staticmethod
    async def should_analyze(session_id: int) -> bool:
        """
        Check if session is ready for AI analysis.

        Returns:
            True if session has 5-10 messages and status is 'collecting'
        """
        session = await db.fetchrow(
            "SELECT status, messages_count FROM engagement_sessions WHERE id = $1",
            session_id
        )

        if not session:
            return False

        # Must be in collecting phase and have enough messages
        return (
            session['status'] == 'collecting' and
            session['messages_count'] >= EngagementManager.COLLECTION_MIN_MESSAGES
        )

    @staticmethod
    async def check_engagement_level(session_id: int) -> str:
        """
        Check engagement level based on USER messages count (not total).
        Admin messages don't count towards engagement threshold.

        Returns:
            'low', 'high', or 'ready_to_analyze'
        """
        # Count only USER messages for engagement level
        user_message_count = await db.fetchval(
            """
            SELECT COUNT(*) FROM session_messages
            WHERE session_id = $1 AND role = 'user'
            """,
            session_id
        )

        if user_message_count is None:
            return 'low'

        # 1-2 user messages = low engagement
        # 3-4 user messages = high engagement (collecting)
        # 5+ user messages = ready to analyze
        if user_message_count <= EngagementManager.LOW_ENGAGEMENT_THRESHOLD:
            return 'low'
        elif user_message_count < EngagementManager.COLLECTION_MIN_MESSAGES:
            return 'high'
        else:
            return 'ready_to_analyze'

    @staticmethod
    async def transition_to_collecting(session_id: int) -> None:
        """Move session from 'engaging' to 'collecting' status"""
        await db.execute(
            """
            UPDATE engagement_sessions
            SET status = 'collecting', updated_at = NOW()
            WHERE id = $1 AND status = 'engaging'
            """,
            session_id
        )
        logger.info(f"Session {session_id} transitioned to collecting phase")

    @staticmethod
    async def analyze_and_offer(session_id: int, user_context: Dict[str, Any]) -> Dict[str, Any]:
        """
        Analyze conversation context and generate Oracle question offer.

        Args:
            session_id: Engagement session ID
            user_context: User demographics (age, gender, archetype, etc.)

        Returns:
            {
                'problem_summary': str,
                'suggested_question': str,
                'offer_message': str
            }
        """
        # Get conversation history
        messages = await db.fetch(
            """
            SELECT role, content, created_at
            FROM session_messages
            WHERE session_id = $1
            ORDER BY created_at ASC
            """,
            session_id
        )

        if not messages:
            logger.warning(f"No messages found for session {session_id}")
            return None

        # Build conversation context for AI
        conversation_text = "\n".join([
            f"{'–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å' if msg['role'] == 'user' else '–ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä'}: {msg['content']}"
            for msg in messages
        ])

        # Create AI prompt for problem analysis
        analysis_prompt = f"""–ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É–π —Å–ª–µ–¥—É—é—â–∏–π –¥–∏–∞–ª–æ–≥ –º–µ–∂–¥—É –ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º –∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º.

–ö–æ–Ω—Ç–µ–∫—Å—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:
- –í–æ–∑—Ä–∞—Å—Ç: {user_context.get('age', '–Ω–µ–∏–∑–≤–µ—Å—Ç–µ–Ω')}
- –ü–æ–ª: {user_context.get('gender', '–Ω–µ–∏–∑–≤–µ—Å—Ç–µ–Ω')}
- –ê—Ä—Ö–µ—Ç–∏–ø: {user_context.get('archetype', '–Ω–µ–∏–∑–≤–µ—Å—Ç–µ–Ω')}

–î–∏–∞–ª–æ–≥:
{conversation_text}

–¢–≤–æ—è –∑–∞–¥–∞—á–∞:
1. –û–ø—Ä–µ–¥–µ–ª–∏ –≥–ª–∞–≤–Ω—É—é –ø—Ä–æ–±–ª–µ–º–∞—Ç–∏–∫—É –∏–ª–∏ –≤–æ–ø—Ä–æ—Å, –∫–æ—Ç–æ—Ä—ã–π –±–µ—Å–ø–æ–∫–æ–∏—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
2. –°—Ñ–æ—Ä–º—É–ª–∏—Ä—É–π –≥–ª—É–±–æ–∫–∏–π —Ñ–∏–ª–æ—Å–æ—Ñ—Å–∫–∏–π –≤–æ–ø—Ä–æ—Å –∫ –û—Ä–∞–∫—É–ª—É –Ω–∞ –æ—Å–Ω–æ–≤–µ —ç—Ç–æ–π –ø—Ä–æ–±–ª–µ–º–∞—Ç–∏–∫–∏

–í–ê–ñ–ù–û: problem_summary –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –Ω–∞–ø–∏—Å–∞–Ω –≤–æ –í–¢–û–†–û–ú –õ–ò–¶–ï (–æ–±—Ä–∞—â–µ–Ω–∏–µ –∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é –∫–∞–∫ "—Ç—ã", "—Ç–µ–±—è", "—Ç–≤–æ–π").
–ù–∞–ø—Ä–∏–º–µ—Ä: "—Ç–µ–±—è –±–µ—Å–ø–æ–∫–æ–∏—Ç...", "—Ç—ã —á—É–≤—Å—Ç–≤—É–µ—à—å...", "—Ç—ã –∏—â–µ—à—å...", "—Ç–µ–±–µ –Ω—É–∂–Ω–æ..."

–û—Ç–≤–µ—Ç –¥–∞–π —Å—Ç—Ä–æ–≥–æ –≤ —Ñ–æ—Ä–º–∞—Ç–µ JSON:
{{
  "problem_summary": "–ö—Ä–∞—Ç–∫–æ–µ —Ä–µ–∑—é–º–µ –ø—Ä–æ–±–ª–µ–º—ã –≤ 1-2 –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è—Ö –≤–æ –≤—Ç–æ—Ä–æ–º –ª–∏—Ü–µ",
  "suggested_question": "–í–æ–ø—Ä–æ—Å –∫ –û—Ä–∞–∫—É–ª—É"
}}
"""

        # Call AI to analyze conversation
        logger.info(f"Analyzing conversation for session {session_id}")
        analysis = await EngagementManager._call_ai_for_analysis(analysis_prompt)

        if not analysis:
            logger.error(f"Failed to analyze session {session_id}")
            return None

        # Save analysis to session
        await db.execute(
            """
            UPDATE engagement_sessions
            SET problem_summary = $1,
                suggested_question = $2,
                status = 'offered',
                offered_at = NOW(),
                updated_at = NOW()
            WHERE id = $3
            """,
            analysis['problem_summary'],
            analysis['suggested_question'],
            session_id
        )

        # Build offer message
        offer_message = f"""üí¨ –°–ª—É—à–∞–π, –ø–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º –Ω–∞—à–µ–≥–æ —Ä–∞–∑–≥–æ–≤–æ—Ä–∞ —è –≤–∏–∂—É, —á—Ç–æ {analysis['problem_summary'].lower()}

–ê —á—Ç–æ –µ—Å–ª–∏ –∑–∞–¥–∞—Ç—å –û—Ä–∞–∫—É–ª—É —Ç–∞–∫–æ–π –≤–æ–ø—Ä–æ—Å: "{analysis['suggested_question']}"?

–ú–Ω–µ –∫–∞–∂–µ—Ç—Å—è, –¥–ª—è —Ç–µ–±—è —ç—Ç–æ —Å–µ–π—á–∞—Å –∞–∫—Ç—É–∞–ª—å–Ω–æ. –•–æ—á–µ—à—å, —è –ø–µ—Ä–µ–¥–∞–º –µ–º—É —ç—Ç–æ—Ç –≤–æ–ø—Ä–æ—Å?"""

        logger.info(f"Generated offer for session {session_id}")

        return {
            'problem_summary': analysis['problem_summary'],
            'suggested_question': analysis['suggested_question'],
            'offer_message': offer_message
        }

    @staticmethod
    async def _call_ai_for_analysis(prompt: str) -> Optional[Dict[str, Any]]:
        """Call AI to analyze conversation and extract problem/question"""
        try:
            # Use OpenAI Chat Completions API directly for analysis (no persona)
            import openai
            import json
            import os

            client = openai.AsyncOpenAI(api_key=os.getenv("OPENAI_API_KEY"))

            # Request JSON response format
            response = await client.chat.completions.create(
                model="gpt-4o-mini",
                messages=[
                    {
                        "role": "system",
                        "content": "–¢—ã –∞–Ω–∞–ª–∏—Ç–∏–∫ –¥–∏–∞–ª–æ–≥–æ–≤. –ê–Ω–∞–ª–∏–∑–∏—Ä—É–π —Ä–∞–∑–≥–æ–≤–æ—Ä—ã –∏ –∏–∑–≤–ª–µ–∫–∞–π –≥–ª–∞–≤–Ω—É—é –ø—Ä–æ–±–ª–µ–º–∞—Ç–∏–∫—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è. –û—Ç–≤–µ—á–∞–π –¢–û–õ–¨–ö–û –≤–∞–ª–∏–¥–Ω—ã–º JSON."
                    },
                    {
                        "role": "user",
                        "content": prompt
                    }
                ],
                temperature=0.7,
                response_format={"type": "json_object"}  # Force JSON output
            )

            response_text = response.choices[0].message.content
            logger.info(f"AI analysis response: {response_text}")

            # Parse JSON response
            analysis = json.loads(response_text)

            # Validate response structure
            if 'problem_summary' in analysis and 'suggested_question' in analysis:
                return analysis
            else:
                logger.error(f"AI response missing required fields: {analysis}")
                return None

        except json.JSONDecodeError as e:
            logger.error(f"Failed to parse AI response as JSON: {e}")
            logger.error(f"Response was: {response_text if 'response_text' in locals() else 'N/A'}")
            return None
        except Exception as e:
            logger.error(f"Error calling AI for analysis: {e}")
            return None

    @staticmethod
    async def pause_session(session_id: int) -> None:
        """Pause session due to low engagement"""
        await db.execute(
            """
            UPDATE engagement_sessions
            SET status = 'paused', updated_at = NOW()
            WHERE id = $1
            """,
            session_id
        )
        logger.info(f"Session {session_id} paused due to low engagement")

    @staticmethod
    async def mark_converted(session_id: int) -> None:
        """Mark session as converted (user accepted Oracle offer)"""
        await db.execute(
            """
            UPDATE engagement_sessions
            SET status = 'converted', converted = TRUE, updated_at = NOW()
            WHERE id = $1
            """,
            session_id
        )
        logger.info(f"Session {session_id} marked as converted")

    @staticmethod
    async def cleanup_old_sessions(days: int = 7) -> int:
        """
        Clean up old sessions that are inactive.

        Args:
            days: Delete sessions older than this many days

        Returns:
            Number of deleted sessions
        """
        cutoff = datetime.now() - timedelta(days=days)

        result = await db.execute(
            """
            DELETE FROM engagement_sessions
            WHERE updated_at < $1
            AND status IN ('paused', 'converted')
            """,
            cutoff
        )

        # Extract number of deleted rows from result
        deleted_count = int(result.split()[-1]) if result else 0

        if deleted_count > 0:
            logger.info(f"Cleaned up {deleted_count} old engagement sessions")

        return deleted_count

    @staticmethod
    async def auto_pause_stale_sessions(hours: int = 24) -> int:
        """
        Auto-pause sessions that have been inactive for too long.

        Args:
            hours: Pause sessions inactive for this many hours

        Returns:
            Number of paused sessions
        """
        cutoff = datetime.now() - timedelta(hours=hours)

        result = await db.execute(
            """
            UPDATE engagement_sessions
            SET status = 'paused', updated_at = NOW()
            WHERE updated_at < $1
            AND status IN ('engaging', 'collecting')
            """,
            cutoff
        )

        paused_count = int(result.split()[-1]) if result else 0

        if paused_count > 0:
            logger.info(f"Auto-paused {paused_count} stale engagement sessions")

        return paused_count
